private Tuple<Dictionary<string, double[]>, DateTime[]> ParseMetricsData(string xmlData)
{
    var metricsData = new Dictionary<string, double[]>();
    var timestamps = new List<DateTime>();

    var xmlDoc = XDocument.Parse(xmlData);
    var ns = xmlDoc.Root.GetNamespaceOfPrefix("ops");
    
    // Extract timestamps once
    var timestampElems = xmlDoc.Descendants(XName.Get("stat", ns.NamespaceName))
                                .Elements(XName.Get("timestamps", ns.NamespaceName))
                                .FirstOrDefault();
    if (timestampElems != null)
    {
        var timestampsStr = timestampElems.Value.Split(' ');
        foreach (var timestamp in timestampsStr)
        {
            if (long.TryParse(timestamp, out long ts))
            {
                timestamps.Add(DateTimeOffset.FromUnixTimeMilliseconds(ts).DateTime);
            }
        }
    }

    // Extract all stat elements
    var stats = xmlDoc.Descendants(XName.Get("stat", ns.NamespaceName));
    
    // Process each stat element
    foreach (var stat in stats)
    {
        var key = stat.Element(XName.Get("statKey", ns.NamespaceName))
                      .Element(XName.Get("key", ns.NamespaceName))
                      .Value;

        if (_metricsToFilter.Contains(key))
        {
            // Extract data
            var dataElems = stat.Element(XName.Get("data", ns.NamespaceName));
            if (dataElems != null)
            {
                var dataStr = dataElems.Value.Split(' ');
                var dataValues = dataStr.Select(d => double.TryParse(d, out double value) ? value : 0.0).ToArray();

                metricsData[key] = dataValues;
            }
        }
    }

    return new Tuple<Dictionary<string, double[]>, DateTime[]>(metricsData, timestamps.ToArray());
}
