private Tuple<Dictionary<string, double[]>, DateTime[]> ParseMetricsData(string xmlData)
{
    var metricsData = new Dictionary<string, double[]>();
    var timestamps = new List<DateTime>();

    var xmlDoc = XDocument.Parse(xmlData);
    var ns = xmlDoc.Root.GetNamespaceOfPrefix("ops");

    // Extract timestamps
    var timestampElems = xmlDoc.Descendants(XName.Get("stat", ns.NamespaceName))
                                .Elements(XName.Get("timestamps", ns.NamespaceName))
                                .FirstOrDefault();

    if (timestampElems != null)
    {
        timestamps = timestampElems.Value.Split(' ')
                      .Select(ts => long.TryParse(ts, out long result) 
                      ? DateTimeOffset.FromUnixTimeMilliseconds(result).DateTime 
                      : DateTime.MinValue)
                      .Where(t => t != DateTime.MinValue)
                      .ToList();
    }

    // Extract all stat elements
    var stats = xmlDoc.Descendants(XName.Get("stat", ns.NamespaceName));

    foreach (var stat in stats)
    {
        var key = stat.Element(XName.Get("statKey", ns.NamespaceName))
                      .Element(XName.Get("key", ns.NamespaceName))
                      .Value;

        if (key.StartsWith("guestfilesystem") && key.EndsWith("|percentage") || _metricsToFilter.Contains(key))
        {
            var dataElems = stat.Element(XName.Get("data", ns.NamespaceName));
            if (dataElems != null)
            {
                var dataValues = dataElems.Value.Split(' ')
                               .Select(d => double.TryParse(d, out double value) ? value : 0.0)
                               .ToArray();

                // Ensure all data arrays match the length of timestamps
                int minLength = Math.Min(timestamps.Count, dataValues.Length);
                if (timestamps.Count > dataValues.Length)
                {
                    // Truncate timestamps to match dataValues length
                    timestamps = timestamps.Skip(timestamps.Count - dataValues.Length).ToList();
                }
                else if (dataValues.Length > timestamps.Count)
                {
                    // Truncate dataValues to match timestamps length
                    dataValues = dataValues.Skip(dataValues.Length - timestamps.Count).ToArray();
                }

                metricsData[key] = dataValues;
            }
        }
    }

    return new Tuple<Dictionary<string, double[]>, DateTime[]>(metricsData, timestamps.ToArray());
}
